<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Poetry Sorting Game</title>
    <link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.5.2/css/bootstrap.min.css">
    <style>
        .line {
            margin-bottom: 10px;
            padding: 10px;
            border: 1px solid #ccc;
            background-color: #f8f9fa;
            border-radius: 0.25rem;
            cursor: pointer;
        }

        .correct {
            background-color: #28a745 !important;
            color: #fff !important;
            border-color: #10461c !important;
        }

        .incorrect {
            background-color: #f5c3c8 !important;
            color: #000 !important;
            border-color: #ef2b3e !important;
        }

        .selected {
            border-color: #000 !important;
            /* Highlight the selected line */
        }
    </style>
</head>

<body>
    <div class="container my-5">
        <h2 class="mb-4">Stanza Shuffle</h2>
        <p>A poetry sorting game</p>
        <textarea id="poemInput" class="form-control mb-3" rows="10" placeholder="Enter a poem here..."></textarea>
        <button onclick="randomizePoem()" class="btn btn-primary mb-3">Randomize & Play</button>
        <button onclick="randomizeUnlockedLines()" class="btn btn-info mb-3">Shuffle Unlocked Lines</button>
        <div class="progress mb-3">
            <div id="progressBar" class="progress-bar" role="progressbar" style="width: 0%;" aria-valuenow="0"
                aria-valuemin="0" aria-valuemax="100">0%</div>
        </div>
        <div id="sortablePoem" tabindex="0"></div>
    </div>

    <script src="https://code.jquery.com/jquery-3.5.1.slim.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@popperjs/core@2.5.2/dist/umd/popper.min.js"></script>
    <script src="https://stackpath.bootstrapcdn.com/bootstrap/4.5.2/js/bootstrap.min.js"></script>
    <script>
        let originalLines = [];
        let selectedLine = null;

        function randomizePoem() {
            const poemText = document.getElementById('poemInput').value.trim();
            if (poemText === '') {
                alert('Please enter a poem.');
                return;
            }
            originalLines = poemText.split('\n').filter(line => line.trim() !== '');
            displayLinesForSorting(shuffleArray([...originalLines]), true);
        }

        function randomizeUnlockedLines() {
            const unlockedLines = document.querySelectorAll('#sortablePoem .line:not(.correct)');
            displayLinesForSorting(shuffleArray(Array.from(unlockedLines).map(line => line.textContent)), false);
        }

        function shuffleArray(array) {
            for (let i = array.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [array[i], array[j]] = [array[j], array[i]];
            }
            return array;
        }

        function displayLinesForSorting(lines, initialDisplay) {
            const container = document.getElementById('sortablePoem');
            container.innerHTML = '';
            lines.forEach((content, index) => {
                const div = document.createElement('div');
                div.textContent = content; // Assuming content is always a string
                div.classList.add('line', 'text-dark', 'mb-2', 'p-2', 'border', 'rounded');
                div.setAttribute('draggable', 'true');

                div.addEventListener('dragstart', handleDragStart, false);
                div.addEventListener('dragenter', handleDragEnter, false);
                div.addEventListener('dragover', handleDragOver, false);
                div.addEventListener('dragleave', handleDragLeave, false);
                div.addEventListener('drop', handleDrop, false);
                div.addEventListener('dragend', handleDragEnd, false);

                container.appendChild(div);
            });

            if (initialDisplay) checkOrder();
        }

        let dragSrcEl = null;

        function handleDragStart(e) {
            // Target (this) element is the source node.
            dragSrcEl = this;

            e.dataTransfer.effectAllowed = 'move';
            e.dataTransfer.setData('text/html', this.innerHTML);
        }

        function handleDragOver(e) {
            if (e.preventDefault) {
                e.preventDefault(); // Necessary. Allows us to drop.
            }

            e.dataTransfer.dropEffect = 'move';  // See the section on the DataTransfer object.

            return false;
        }

        function handleDragEnter(e) {
            // this / e.target is the current hover target.
            this.classList.add('over');
        }

        function handleDragLeave(e) {
            this.classList.remove('over');  // this / e.target is previous target element.
        }

        function handleDrop(e) {
            // this/e.target is current target element.
            if (e.stopPropagation) {
                e.stopPropagation(); // Stops some browsers from redirecting.
            }

            // Don't do anything if dropping the same line we're dragging.
            if (dragSrcEl != this) {
                // Set the source line's HTML to the HTML of the line we dropped on.
                dragSrcEl.innerHTML = this.innerHTML;
                this.innerHTML = e.dataTransfer.getData('text/html');

                // Update order and progress after dropping
                checkOrder();
            }

            return false;
        }

        function handleDragEnd(e) {
            // this/e.target is the source node.
            var lines = document.querySelectorAll('.line');
            [].forEach.call(lines, function (line) {
                line.classList.remove('over');
            });
        }

        function getDragAfterElement(container, y) {
            const draggableElements = [...container.querySelectorAll('.line:not(.dragging)')];

            return draggableElements.reduce((closest, child) => {
                const box = child.getBoundingClientRect();
                const offset = y - box.top - box.height / 2;
                if (offset < 0 && offset > closest.offset) {
                    return { offset: offset, element: child };
                } else {
                    return closest;
                }
            }, { offset: Number.NEGATIVE_INFINITY }).element;
        }


        function selectLine(line) {
            if (selectedLine) {
                selectedLine.classList.remove('selected');
            }
            line.classList.add('selected');
            selectedLine = line;
        }

        function handleKeyDown(e) {
            const index = Array.from(e.target.parentNode.children).indexOf(e.target);
            if (e.key === 'ArrowUp' && index > 0) {
                e.target.parentNode.insertBefore(e.target, e.target.previousElementSibling);
                checkOrder();
            } else if (e.key === 'ArrowDown' && index < e.target.parentNode.children.length - 1) {
                e.target.parentNode.insertBefore(e.target.nextElementSibling, e.target);
                checkOrder();
            }
        }

        function checkOrder() {
            const lines = document.querySelectorAll('#sortablePoem .line');
            let correctCount = 0;
            lines.forEach((line, index) => {
                if (line.textContent.trim() === originalLines[index].trim()) {
                    line.classList.add('correct', 'bg-success', 'text-white');
                    line.classList.remove('incorrect');
                    correctCount++;
                } else {
                    line.classList.add('incorrect', 'bg-danger', 'text-white');
                    line.classList.remove('correct');
                }
            });
            updateProgressBar(correctCount, lines.length);
        }

        function updateProgressBar(correctCount, totalCount) {
            const percentage = Math.round((correctCount / totalCount) * 100);
            const progressBar = document.getElementById('progressBar');
            progressBar.style.width = `${percentage}%`;
            progressBar.setAttribute('aria-valuenow', percentage);
            progressBar.textContent = `${percentage}%`;
        }
    </script>
</body>

</html>